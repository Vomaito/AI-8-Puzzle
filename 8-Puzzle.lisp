(LOAD common.lisp)
(setq INICIAL '(0 1 2 4 7 3 8 5 6))
(setq SOLUCION '(1 2 3 4 5 6 7 8 0))

(DEFUN ISVALID()
	(SETQ NUMMOV 0)
	(DOTIMES (I 9)
		(SETQ ST (NTH I INICIAL))
		(((NEQ ST 0)
			(DOTIMES (J (- 8 I))
				(SETQ ND (NTH (+ J I 1) INICIAL))
				(((NEQ ND 0)
					((> ST ND) (INCQ NUMMOV))
				))
			)
		))
	)
	((= 0 (MOD NUMMOV 2)) T)
	nil
)
(DEFUN ELEMENT_AT(INDEX LST)
  (NTH INDEX LST)
)
(DEFUN HEURISTICA(NODO)
  (SETQ DIST 0)
  (SETQ INDEX 1)
  (LOOP
    ((= 10 INDEX)
    DIST
    )
    (SETQ
      INIX (MOD (- (ELEMENT_AT INDEX NODO) 1) 3)
      INIY (REM (- (ELEMENT_AT INDEX NODO) 1) 3)
      FINX (MOD (- (ELEMENT_AT INDEX SOLUCION) 1) 3)
      FINY (REM (- (ELEMENT_AT INDEX SOLUCION) 1) 3)
    )
    (SETQ
      DIST (+ DIST (ABS((- INIX FINX))) (ABS((- INIY FINY))))
    )
    (INCQ INDEX)
  )
  DIST
)
(DEFUN GETINDEX(NODO ELEMENTO)
(SETQ INDEX 1)
  (LOOP
    ((= INDEX 10))
    ((= (NTH INDEX NODO) ELEMENTO)
      INDEX
    )
    (INCQ INDEX)
  )
  NIL
)
(DEFUN VALIDMOVE(NODO MOVE)
  ((= MOVE 'U')
    (SETQ INDEX (GETINDEX(NODO 0))
      INIY (REM (- (ELEMENT_AT INDEX NODO) 1) 3)
    )
    ((= INIY 0)
      NIL
    )
    T
  )
  ((= MOVE 'D')
    (SETQ INDEX (GETINDEX(NODO 0))
      INIY (REM (- (ELEMENT_AT INDEX NODO) 1) 3)
    )
    ((= INIY 2)
      NIL
    )
    T
  )
  ((= MOVE 'L')
    (SETQ INDEX (GETINDEX(NODO 0))
      INIX (MOD (- (ELEMENT_AT INDEX NODO) 1) 3)
    )
    ((= INIY 0)
      NIL
    )
    T
  )
  ((= MOVE 'R')
    (SETQ INDEX (GETINDEX(NODO 0))
      INIX (MOD (- (ELEMENT_AT INDEX NODO) 1) 3)
    )
    ((= INIY 2)
      NIL
    )
    T
  )
)
(DEFUN SWAP(X Y NODE)
  (ROTATEF (NTH X NODE) (NTH Y NODE))
)
(DEFUN MAKEMOVE(NODO MOVE)
  ((VALIDMOVE(NODO MOVE))
    (SETQ INDEXZERO GETINDEX(NODO 0))
    ((= MOVE 'U')
      (SWAP INDEXZERO INDEXZERO-3 NODO)
    )
    ((= MOVE 'D')
      (SWAP INDEXZERO INDEXZERO+3 NODO)
    )
    ((= MOVE 'L')
      (SWAP INDEXZERO INDEXZERO-1 NODO)
    )
    ((= MOVE 'R')
      (SWAP INDEXZERO INDEXZERO+1 NODO)
    )
  )
  NIL
)
(DEFUN ORDER2OPEN (LST)
  (SORT LST
    (LAMBDA (X Y)
      (< (+ (SECOND X) (THIRD X)) (+ (SECOND Y) (THIRD Y))))
      )
; SE USA NODO NIVEL MANHATTAN MOVE
(DEFUN EXPANDIR(OPTION)
  (SETQ
    UP MAKEMOVE((FIRST OPTION) 'U')
    DOWN MAKEMOVE((FIRST OPTION) 'D')
    LEFT MAKEMOVE((FIRST OPTION) 'L')
    RIGHT MAKEMOVE((FIRST OPTION) 'R')
    LSTNEXT NIL
    )
  (((NEQ UP NIL)
      (PUSH (LIST UP (+ 1 (SECOND OPTION)) (HEURISTICA UP) 'U' ) LSTNEXT )
  ))
  (((NEQ DOWN NIL)
      (PUSH (LIST DOWN (+ 1 (SECOND OPTION)) (HEURISTICA UP) 'D' ) LSTNEXT )
  ))
  (((NEQ RIGHT NIL)
      (PUSH (LIST RIGHT (+ 1 (SECOND OPTION)) (HEURISTICA UP) 'R' ) LSTNEXT )
  ))
  (((NEQ LEFT NIL)
      (PUSH (LIST LEFT (+ 1 (SECOND OPTION)) (HEURISTICA UP) 'L' ) LSTNEXT )
  ))
    (ORDER20PEN LSTNEXT)
)
(DEFUN PRINT_PUZZLE (NODO)
  (SETQ INDEX 0)
  (LOOP
	((= INDEX 9))
      (((= 2 (MOD INDEX 3))
        (PRIN1(NTH INDEX NODO))
        (TERPRI)
      ))
      (((NEQ 2 (MOD INDEX 3))
          (PRIN1(NTH INDEX NODO))
      ))
      (INCQ INDEX)
  )
)
(DEFUN ADDOPEN (OPTION)
  (SETQ
    INDEX 0
    COST (+ (SECOND OPTION) (THIRD OPTION))
  )
  (LOOP
    (SET NODO (NTH INDEX OPENSTACK))
    (((NEQ NODO NIL)
      ((< COST (+ (SECOND NODO) (THIRD NODO)) )
        (SETQ
          OPENSTACK (APPEND (FIRSTN INDEX OPENSTACK) (LIST OPTION) (NTHCDR INDEX OPENSTACK))
        )
      )
    ))
    (INCQ INDEX)
    ((NULL NODO)
      (SETQ OPENSTACK (APPEND OPENSTACK (LIST OPTION)))
    )
  )
)
